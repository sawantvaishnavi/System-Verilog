/*    #basic
Type of assertion:
  1.Simple immediate assertion:               assert
  2.Observed deffered immediate assertion:    assert #0
  3.Final deffered immediate assertion:       assert final
  4.Concurrent assertion:                     assert property
*/
/*

  Rules of Assertion:

  Rule 1:

  1. Simple Immediate Assertion (sia)  -->  Require Procedural block
    It could be either
      1: initial
          begin
          end
      2:  always@(*)  / always@(posedge clk)  /  always_comb  /  always_ff
            begin
            end

  2. odia + fdia  -->  do not require procedural block for combinational ckt
                        require procedural block for sequential

  Rule 2: Pass/Fail Action

    1. sia --> supports multiple pass / fail action
    2. odia + fdia  --> supports single pass / fail

*/
/*
Expression:

1. sia :       assert ( expression of expected behaviour)  $info ("pass action") ; else $error ("fail action");
2.odia :       assert #0 ( )  $info ("pass action") ; else $error ("fail action");
3.fdia :       assert final ( )  $info ("pass action") ; else $error ("fail action");


*/
/*
Disabling Assertion: 1.Specific assertion check  2.All assertion check

1. $assertoff();
   $asserton();

2. sia:  if-else, case
   dia:  disable A1;

Disabling Assertion at specific condition: 
 A2: assert property ( @(posedge clk) disable iff(rst)    req |=> ack )$info("Suc at %0t",$time);       //if reset is high then disble the following assertion

*/

/*
Format of concurrent Assertion: 
   1. Name:  assert property (@ (posedge clk)  expression )  $info(pass action); else $error(fail action);         //here expression is evaluated at each positive edge of clock, this might not be needed every time

Restrict the assertion by evaluating only once:
   2. initial  Name: assert property (. . expression . . )  pass/fail               // initial will execute only once
   3. assert property ( @(posedge clk)  $rose(temp) 1 ->     expression  )   pass/ fail     // creating temporary variable temp which is high for posedge of clk only once
*/

/*
Concurrent assertion required valid clock edge to evaluate an expression.
Uderstanding clock edges: it can be -> @(posedge clk) / @(negedge clk) / @(edge clk) (any edge)

 Name:  assert property (@ (clockedge where signal is evaluating)  expression )  $info(pass action); $error(fail action); 
*/






