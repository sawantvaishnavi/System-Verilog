/*    #basic
Type of assertion:
  1.Simple immediate assertion:               assert
  2.Observed deffered immediate assertion:    assert #0
  3.Final deffered immediate assertion:       assert final
  4.Concurrent assertion:                     assert property
*/
/*

  Rules of Assertion:

  Rule 1:

  1. Simple Immediate Assertion (sia)  -->  Require Procedural block
    It could be either
      1: initial
          begin
          end
      2:  always@(*)  / always@(posedge clk)  /  always_comb  /  always_ff
            begin
            end

  2. odia + fdia  -->  do not require procedural block for combinational ckt
                        require procedural block for sequential

  Rule 2: Pass/Fail Action

    1. sia --> supports multiple pass / fail action
    2. odia + fdia  --> supports single pass / fail

*/
/*
Expression:

1. sia :       assert ( expression of expected behaviour)  $info ("pass action") ; else $error ("fail action");
2.odia :       assert #0 ( )  $info ("pass action") ; else $error ("fail action");
3.fdia :       assert final ( )  $info ("pass action") ; else $error ("fail action");

*/
/*
Disabling Assertion: 1.Specific assertion check  2.All assertion check

1. $assertoff();
   $asserton();

2. sia:  if-else, case
   dia:  disable A1;

Disabling Assertion at specific condition: 
 A2: assert property ( @(posedge clk) disable iff(rst)    req |=> ack )$info("Suc at %0t",$time);       //if reset is high then disble the following assertion

*/

/*
Format of concurrent Assertion: 
   1. Name:  assert property (@ (posedge clk)  expression )  $info(pass action); else $error(fail action);         //here expression is evaluated at each positive edge of clock, this might not be needed every time

Restrict the assertion by evaluating only once:
   2. initial  Name: assert property (. . expression . . )  pass/fail               // initial will execute only once
   3. assert property ( @(posedge clk)  $rose(temp) 1 ->     expression  )   pass/ fail     // creating temporary variable temp which is high for posedge of clk only once
*/

/*
Concurrent assertion required valid clock edge to evaluate an expression.
Uderstanding clock edges: it can be -> @(posedge clk) / @(negedge clk) / @(edge clk) (any edge)

 Name:  assert property (@ (clockedge where signal is evaluating)  expression )  $info(pass action); $error(fail action); 
*/

/*
implication operator:
1. overlapping:      |->   The evaluation of the consequent starts immediately on the same clock cycle if the antecedent holds true.
2. non overlapping:  |=>  if the antecedent (left side) is true at a clock edge, the consequent (right side) must be true on the next clock edge, 
                          ensuring the trigger and response don't happen in the same cycle. 
*/

/* System Task:
1. $sampled:
We already know concurrent assertion evaluates an expression by considering the value that exists in the Preponed region.
Now if we use info, monitor, strobe or any other reporting macros, all of them are executed in an reactive region.
So if you try to print the value of a variable utilizing a reporting macros, you will be getting the value from a reactive region instead of a preponed region.

in case of  multibit $rose, $fell lsb bits are checked.

2. $rose :
This is used to detect whether signal have a positive edge only once.

3. $fell :
Used to detect falling edge of signal

4. $past:
 Used to acess the values of signal from previous clock. the command is having 4 arguments:
   $past (signal, no. of clock ticks, gating, edge);

if gating is 1 -> then past will behave exactly as a previous case where we do not have any getting.  (normal case)
if enable is 0 ->  then in that case pass function will return the value that we have for the past function in the previous execution.   (just like clock gating)
So in an entire simulation, if past is executed at least once, then pass function will return that value when getting is zero.

5.$stable: 
if there is no change between current value and previous valune then output will be 1 else 0.

6. $changed:
if there is change between current value and previous valune then output will be 1 else 0.

//One hot basically means we should have only single bit with a value of 1 in the case of multiple bit signal.
7.$onehot:
onehot will return true (1) only when any one bit have value 1 while rest bits should be 0.

//onehot we usually find in the encoding of an FSM and the initial value for state is always all zero. 
//So that should not lead to the failure because we ourself have initialized a variable to a value of zero.
//So to ignore a failure when we have all zeros in a signal, we have onehotzero.

8.$onehot0
So this will return true if we have all zeros in a signal and for the rest of the cases it will return True only when any one bit have a value of one.

9. $onecold: 
only one bit should be zero then true else false.
compliment of onecold encoding is onehot encoding.

10. $isunkown:
This is used to check if any bit of our signal have an undefined or high impedance value (x/z).

11. $countbits:
return the number of bits which have a matching value.
So count bit have two arguments. First one is the signal itself and second one is the value that we are interested in.

12. $countones:

*/

/*
Delay Operator:

1. Constant Delay: ##n  is used where n is number of clock cycles
2. Variable : ##[min:max]  Signal will be high between min and max
3. Unbound: ##[ : $]  mention starting clock tick. somewhere in simulation signal will be high
*/

/*
Repetion Operator:

1.Consecutive:
2.Non-Consecutive:
*/
/*
Boolean Operator:
1.and  : evaluate when lonest sequence evaluated true
2.or   : evaluated when smallest sequence evaluated true
3.not

Matching Operator:
1.throughout:  used to check whether boolean signal or Boolean expression lies inside the sequence 
2.within    :  used to verify whether our test sequence lies inside the reference sequence
3.intersect: Same start and end points
*/



