/*    #basic
Type of assertion:
  1.Simple immediate assertion:               assert
  2.Observed deffered immediate assertion:    assert #0
  3.Final deffered immediate assertion:       assert final
  4.Concurrent assertion:                     assert property
*/
/*

  Rules of Assertion:

  Rule 1:

  1. Simple Immediate Assertion (sia)  -->  Require Procedural block
    It could be either
      1: initial
          begin
          end
      2:  always@(*)  / always@(posedge clk)  /  always_comb  /  always_ff
            begin
            end

  2. odia + fdia  -->  do not require procedural block for combinational ckt
                        require procedural block for sequential

  Rule 2: Pass/Fail Action

    1. sia --> supports multiple pass / fail action
    2. odia + fdia  --> supports single pass / fail

*/
/*
Expression:

1. sia :       assert ( expression of expected behaviour)  $info ("pass action") ; else $error ("fail action");
2.odia :       assert #0 ( )  $info ("pass action") ; else $error ("fail action");
3.fdia :       assert final ( )  $info ("pass action") ; else $error ("fail action");


*/
/*
Disabling Assertion: 1.Specific assertion check  2.All assertion check

1. $assertoff();
   $asserton();

2. sia:  if-else, case
   dia:  disable A1;

Disabling Assertion at specific condition: 
 A2: assert property ( @(posedge clk) disable iff(rst)    req |=> ack )$info("Suc at %0t",$time);       //if reset is high then disble the following assertion

*/

/*
Format of concurrent Assertion: 
   1. Name:  assert property (@ (posedge clk)  expression )  $info(pass action); else $error(fail action);         //here expression is evaluated at each positive edge of clock, this might not be needed every time

Restrict the assertion by evaluating only once:
   2. initial  Name: assert property (. . expression . . )  pass/fail               // initial will execute only once
   3. assert property ( @(posedge clk)  $rose(temp) 1 ->     expression  )   pass/ fail     // creating temporary variable temp which is high for posedge of clk only once
*/

/*
Concurrent assertion required valid clock edge to evaluate an expression.
Uderstanding clock edges: it can be -> @(posedge clk) / @(negedge clk) / @(edge clk) (any edge)

 Name:  assert property (@ (clockedge where signal is evaluating)  expression )  $info(pass action); $error(fail action); 
*/

/*
implication operator:
1. overlapping
2. non overlapping
*/

/* System Task:
1. $sampled:
We already know concurrent assertion evaluates an expression by considering the value that exists in the Preponed region.
Now if we use info, monitor, strobe or any other reporting macros, all of them are executed in an reactive region.
So if you try to print the value of a variable utilizing a reporting macros, you will be getting the value from a reactive region instead of a preponed region.

2. $rose :
This is used to detect whether signal have a positive edge only once.

3. $fell :
Used to detect falling edge of signal

4. $past:
 Used to acess the values of signal from previous clock. the comand is having 4 arguments:
   $past (signal, no. of clock ticks, gating, edge);

if gating is 1 -> then past will behave exactly as a previous case where we do not have any getting.  (normal case)
if enable is 0 ->  then in that case pass function will return the value that we have for the past function in the previous execution.   (just like clock gating)
So in an entire simulation, if past is executed at least once, then pass function will return that value when getting is zero.
*/






